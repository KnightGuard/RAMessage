package com.softtanck.ramessageclient.core.engine

import android.os.Handler
import android.os.Looper
import android.os.Message
import android.os.RemoteException
import android.util.Log
import android.util.SparseArray
import com.softtanck.model.RaCustomMessenger
import com.softtanck.ramessageclient.core.listener.RaRemoteMessageListener
import java.lang.ref.WeakReference
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger

/**
 * @author Softtanck
 * @date 2022/3/12
 * Description: TODO
 */
open class BaseClientHandler : Handler {
    private val TAG: String = this.javaClass.simpleName

    constructor() : super()
    constructor(looper: Looper) : super(looper)
    constructor(looper: Looper, callback: Callback) : super(looper, callback)

    /**
     * The transaction ID of a message and generated by the client.
     * Also, It is a thread-safe. see [safelyIncrement]
     */
    private val msgTransactionNumber = AtomicInteger(0)

    /**
     * A flag to show the status of client.
     * true: Bound, otherwise not.
     */
    protected val clientBoundStatus = AtomicBoolean(false)

    @Volatile
    protected var outputMessenger: RaCustomMessenger? = null

    /**
     * Remember all callbacks from the client. And WeakReference is used as value.
     * That can be void memory leaks here.
     */
    protected val callbacks: SparseArray<WeakReference<RaRemoteMessageListener>> = SparseArray<WeakReference<RaRemoteMessageListener>>()

    /**
     * Send a message to server with sync
     * @param message the message
     * @return null or message from server
     */
    protected fun sendMsgSync(message: Message): Message? = if (clientBoundStatus.get()) {
        try {
            if (outputMessenger != null) {
                outputMessenger!!.sendSync(message.apply {
                    arg1 = safelyIncrement()
                })
            } else {
                null
            }
        } catch (e: RemoteException) {
            Log.e(TAG, "[CLIENT] Failed to send sync msg to server, msg: $message, reason: ${e.message}")
            null
        }
    } else {
        Log.w(TAG, "[CLIENT] You are disconnected with server, Ignore this the message. msg:$message")
        null
    }

    /**
     * Send a message to server with async
     * @param message the message
     * @param raRemoteMessageListener remote callback
     */
    protected fun sendMsgAsync(message: Message, raRemoteMessageListener: RaRemoteMessageListener?) {
        if (clientBoundStatus.get()) {
            try {
                outputMessenger?.send(message.apply {
                    arg1 = safelyIncrement()
                    synchronized(callbacks) { // Make sure it is thread-safely
                        callbacks.put(arg1, WeakReference(raRemoteMessageListener))
                    }
                })
            } catch (e: RemoteException) {
                Log.e(TAG, "[CLIENT] Failed to send sync msg to server, msg: $message, reason: ${e.message}")
                safelyNULLCallbackRemoteMessage(raRemoteMessageListener)
            }
        } else {
            Log.w(TAG, "[CLIENT] You are disconnected with server, Ignore this the message. msg:$message")
            safelyNULLCallbackRemoteMessage(raRemoteMessageListener)
        }
    }

    /**
     * This method is auto increment the number of transaction.
     * Will be reset to 0 if it more than [Int.MAX_VALUE]
     */
    private fun safelyIncrement(): Int {
        if (msgTransactionNumber.incrementAndGet() >= Int.MAX_VALUE) {
            @Suppress("ControlFlowWithEmptyBody")
            while (!msgTransactionNumber.compareAndSet(msgTransactionNumber.get(), 0));
        }
        return msgTransactionNumber.get()
    }

    // TODO : TBD
    private fun safelyNULLCallbackRemoteMessage(raRemoteMessageListener: RaRemoteMessageListener?) {
        try {
            raRemoteMessageListener?.onMessageArrived(null)
        } finally {

        }
    }

}