package com.softtanck.ramessageclient.core.engine

import android.os.Handler
import android.os.Looper
import android.os.Message
import android.os.RemoteException
import android.util.Log
import android.util.SparseArray
import com.softtanck.ramessage.IRaMessenger
import com.softtanck.ramessageclient.core.listener.RaRemoteMessageListener
import java.lang.ref.WeakReference
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger

/**
 * @author Softtanck
 * @date 2022/3/12
 * Description: TODO
 */
internal abstract class BaseClientHandler : Handler {
    private val TAG: String = this.javaClass.simpleName

    constructor() : super()
    constructor(looper: Looper) : super(looper)
    constructor(looper: Looper, callback: Callback) : super(looper, callback)

    val innerMessenger: IRaMessenger.Stub = RaCustomClientMessengerImpl()

    /**
     * The transaction ID of a message and generated by the client.
     * Also, It is a thread-safe. see [safelyIncrement]
     */
    private val msgTransactionNumber = AtomicInteger(0)

    /**
     * A flag to show the status of client.
     * true: Bound, otherwise not.
     */
    protected val clientBoundStatus = AtomicBoolean(false)

    @Volatile
    protected var outputMessenger: IRaMessenger? = null

    /**
     * Remember all callbacks from the client. And WeakReference is used as value.
     * That can be void memory leaks here.
     */
    protected val singleCallbacks: SparseArray<WeakReference<RaRemoteMessageListener>> = SparseArray<WeakReference<RaRemoteMessageListener>>()

    /**
     * Remember all callbacks from the client. And WeakReference is used as value.
     * That can be void memory leaks here.
     */
    protected val broadcastCallbacks = mutableListOf<WeakReference<RaRemoteMessageListener>>()

    /**
     * Add a broadcast callback to the list.
     * @param remoteMessageListener The callback to be added.
     */
    fun addRemoteBroadCastMessageCallback(remoteMessageListener: RaRemoteMessageListener) {
        synchronized(broadcastCallbacks) {
            broadcastCallbacks.add(WeakReference(remoteMessageListener))
        }
    }

    /**
     * Remove a broadcast callback from the list.
     */
    fun removeRemoteBroadCastMessageCallback(remoteMessageListener: RaRemoteMessageListener) {
        synchronized(broadcastCallbacks) {
            broadcastCallbacks.removeAll { it.get() == remoteMessageListener }
        }
    }

    /**
     * Clear all broadcast callbacks.
     */
    fun clearRemoteBroadCastMessageCallbacks() {
        synchronized(broadcastCallbacks) {
            broadcastCallbacks.clear()
        }
    }

    /**
     * Send a message to server with sync
     * @param message the message
     * @return null or message from server
     */
    protected fun sendSyncMessageToServer(message: Message): Message? = if (clientBoundStatus.get()) {
        try {
            outputMessenger?.sendSync(message.apply {
                arg1 = safelyIncrement()
            })
        } catch (e: RemoteException) {
            Log.e(TAG, "[CLIENT] Failed to send sync msg to server, msg: $message, reason: ${e.message}")
            null
        }
    } else {
        Log.w(TAG, "[CLIENT] You are disconnected with server, Ignore this the message. msg:$message")
        null
    }

    /**
     * Send a message to server with async
     * @param message the message
     * @param raRemoteMessageListener remote callback
     */
    protected fun sendAsyncMessageToServer(message: Message, raRemoteMessageListener: RaRemoteMessageListener?) {
        if (clientBoundStatus.get()) {
            try {
                outputMessenger?.send(message.apply {
                    arg1 = safelyIncrement()
                    synchronized(singleCallbacks) { // Make sure it is thread-safely
                        singleCallbacks.put(arg1, WeakReference(raRemoteMessageListener))
                    }
                }) ?: Log.e(TAG, "[CLIENT] Failed to send sync msg to server, since your messenger is null, msg: $message")
            } catch (e: RemoteException) {
                Log.e(TAG, "[CLIENT] Failed to send sync msg to server, msg: $message, reason: ${e.message}")
                safelyNULLCallbackRemoteMessage(raRemoteMessageListener)
            }
        } else {
            Log.w(TAG, "[CLIENT] You are disconnected with server, Ignore this the message. msg:$message")
            safelyNULLCallbackRemoteMessage(raRemoteMessageListener)
        }
    }

    /**
     * This method is auto increment the number of transaction.
     * Will be reset to 0 if it more than [Int.MAX_VALUE]
     */
    private fun safelyIncrement(): Int {
        if (msgTransactionNumber.incrementAndGet() >= Int.MAX_VALUE) {
            @Suppress("ControlFlowWithEmptyBody")
            while (!msgTransactionNumber.compareAndSet(msgTransactionNumber.get(), 0));
        }
        return msgTransactionNumber.get()
    }

    // TODO : TBD
    private fun safelyNULLCallbackRemoteMessage(raRemoteMessageListener: RaRemoteMessageListener?) {
        try {
            raRemoteMessageListener?.onMessageArrived(null)
        } finally {

        }
    }

    private inner class RaCustomClientMessengerImpl : IRaMessenger.Stub() {
        override fun send(msg: Message) {
            msg.sendingUid = getCallingUid()
            this@BaseClientHandler.sendMessage(msg)
        }

        override fun sendSync(msg: Message): Message {
            msg.sendingUid = getCallingUid()
            return this@BaseClientHandler.onRemoteMessageArrived(msg, true) ?: return Message.obtain(msg)
        }
    }

    abstract fun onRemoteMessageArrived(msg: Message, isSync: Boolean): Message?

}