package com.softtanck.ramessageclient.core.engine

import android.os.*
import android.util.Log
import android.util.SparseArray
import com.softtanck.model.RaCustomMessenger
import com.softtanck.ramessage.IRaMessenger
import com.softtanck.ramessageclient.core.listener.RaRemoteMessageListener
import java.lang.ref.WeakReference
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger

/**
 * @author Softtanck
 * @date 2022/3/12
 * Description: TODO
 */
internal abstract class BaseClientHandler<T : Parcelable> : Handler {
    private val TAG: String = this.javaClass.simpleName

    constructor() : super()
    constructor(looper: Looper) : super(looper)
    constructor(looper: Looper, callback: Callback) : super(looper, callback)

    /**
     * The transaction ID of a message and generated by the client.
     * Also, It is a thread-safe. see [safelyIncrement]
     */
    private val msgTransactionNumber = AtomicInteger(0)

    /**
     * A flag to show the status of client.
     * true: Bound, otherwise not.
     */
    protected val clientBoundStatus = AtomicBoolean(false)

    @Volatile
    protected var outputMessenger: T? = null

    /**
     * Remember all callbacks from the client. And WeakReference is used as value.
     * That can be void memory leaks here.
     */
    protected val callbacks: SparseArray<WeakReference<RaRemoteMessageListener>> = SparseArray<WeakReference<RaRemoteMessageListener>>()

    /**
     * Send a message to server with sync
     * @param message the message
     * @return null or message from server
     */
    protected fun sendSyncMessageToServer(message: Message): Message? = if (clientBoundStatus.get()) {
        try {
            if (outputMessenger != null && outputMessenger is RaCustomMessenger) {
                (outputMessenger as RaCustomMessenger).sendSync(message.apply {
                    arg1 = safelyIncrement()
                })
            } else {
                throw IllegalArgumentException("Only the custom messenger can be used to send the sync message")
            }
        } catch (e: RemoteException) {
            Log.e(TAG, "[CLIENT] Failed to send sync msg to server, msg: $message, reason: ${e.message}")
            null
        }
    } else {
        Log.w(TAG, "[CLIENT] You are disconnected with server, Ignore this the message. msg:$message")
        null
    }

    /**
     * Send a message to server with async
     * @param message the message
     * @param raRemoteMessageListener remote callback
     */
    protected fun sendAsyncMessageToServer(message: Message, raRemoteMessageListener: RaRemoteMessageListener?) {
        if (clientBoundStatus.get()) {
            try {
                when (outputMessenger) {
                    is RaCustomMessenger -> {
                        (outputMessenger as? RaCustomMessenger)?.send(message.apply {
                            arg1 = safelyIncrement()
                            synchronized(callbacks) { // Make sure it is thread-safely
                                callbacks.put(arg1, WeakReference(raRemoteMessageListener))
                            }
                        })
                    }
                    is Messenger -> {
                        (outputMessenger as? Messenger)?.send(message.apply {
                            arg1 = safelyIncrement()
                            if (raRemoteMessageListener != null) {
                                synchronized(callbacks) { // Make sure it is thread-safely
                                    callbacks.put(arg1, WeakReference(raRemoteMessageListener))
                                }
                            }
                        })
                    }
                    else -> {
                        Log.e(TAG, "[CLIENT] Failed to send sync msg to server, since your messenger is null, msg: $message")
                    }
                }
            } catch (e: RemoteException) {
                Log.e(TAG, "[CLIENT] Failed to send sync msg to server, msg: $message, reason: ${e.message}")
                safelyNULLCallbackRemoteMessage(raRemoteMessageListener)
            }
        } else {
            Log.w(TAG, "[CLIENT] You are disconnected with server, Ignore this the message. msg:$message")
            safelyNULLCallbackRemoteMessage(raRemoteMessageListener)
        }
    }

    /**
     * This method is auto increment the number of transaction.
     * Will be reset to 0 if it more than [Int.MAX_VALUE]
     */
    private fun safelyIncrement(): Int {
        if (msgTransactionNumber.incrementAndGet() >= Int.MAX_VALUE) {
            @Suppress("ControlFlowWithEmptyBody")
            while (!msgTransactionNumber.compareAndSet(msgTransactionNumber.get(), 0));
        }
        return msgTransactionNumber.get()
    }

    // TODO : TBD
    private fun safelyNULLCallbackRemoteMessage(raRemoteMessageListener: RaRemoteMessageListener?) {
        try {
            raRemoteMessageListener?.onMessageArrived(null)
        } finally {

        }
    }

    class RaCustomClientMessengerImpl(private val handler: Handler) : IRaMessenger.Stub() {
        override fun send(msg: Message) {
            msg.sendingUid = getCallingUid()
            handler.sendMessage(msg)
        }

        override fun sendSync(msg: Message): Message {
            msg.sendingUid = getCallingUid()
            if (this.handler is RaClientHandler) {
                return this.handler.onRemoteMessageArrived(msg, true) ?: return Message.obtain(msg)
            } else {
                throw IllegalArgumentException("Only the custom messenger can be used to send the sync message")
            }
        }
    }

    abstract fun onRemoteMessageArrived(msg: Message, isSync: Boolean): Message?

}